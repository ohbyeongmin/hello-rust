# References and Borrowing

`String` 타입을 함수에 전달하고 다시 쓰고 싶어도 못쓰는 상황이 발생한다. 이때 `String` 값의 참조자를 만들 수 있다.
참조자(reference)는 해당 주소에 저장된 데이터에 접근할 수 있도록 해주는 주소값에 해당하는, 포인터와 같은 것이다. 그 데이터는 다른 어떤 변수가 소유하고 있다. 포인터와는 달리, 참조자는 살아있는 동안 특정 타입에 대한 유효한 값을 가리킴을 보장해 준다.

```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

`&` 기호가 참조자를 나타내고, 어떤 값의 소유권을 가져오지 않고 해당 값을 참조할 수 있도록 해준다.
역참조 기호는 `*`이다

이처럼 참조자를 만드는 행위를 대여(borrow) 라고 한다.

만약, 빌린 값을 수정하면 어떻게 될까? 변수가 기본적으로 불변성을 지니듯, 참조자도 마찬가지로 참조하는 것을 수정할 수 없다.

## 가변 참조자

가변 참조자(mutable reference)를 사용하여 참조자가 빌린 변수를 수정할 수 있다.

```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

가변 참조자는 한 가지 큰 제약사항이 있다: 어떤 값에 대한 가변 참조자가 있다면, 그 값에 대한 참조자는 더 이상 만들 수 없다.

```rust
    let mut s = String::from("hello");

    let r1 = &mut s;
    let r2 = &mut s;

    println!("{}, {}", r1, r2);

```

위 코드는 에러가 난다.

이 제약 때문에 러스트는 컴파일 타임에 데이터 경합(data rase)을 방지할 수 있다.

데이터 경합 조건:

- 둘 이상의 포인터가 동시에 같은 데이터에 접근
- 포인터 중 하나 이상이 데이터에 쓰기 작업을 시행
- 데이터 접근 동기화 메커니즘이 없음

어떤 값에 대한 불변 참조자가 있는 동안 같은 값의 가변 참조자를 만드는 것은 불가능 하다.

불변 참조자의 경우 어느 쪽에서도 사용 중인 값이 중간에 변경되지 않으니 여러 개의 불변 참조자를 만드는 것은 가능하다.

참조자는 정의된 지점부터 시작하여 해당 참조자가 마지막으로 사용된 부분까지 유효하다.

```rust
    let mut s = String::from("hello");

    let r1 = &s; // 문제없음
    let r2 = &s; // 문제없음
    println!("{} and {}", r1, r2);
    // 이 지점 이후로 변수 r1과 r2는 사용되지 않습니다

    let r3 = &mut s; // 문제없음
    println!("{}", r3);

```

## 댕글링 참조

댕글링 포인터(dangling pointer, 이미 해제된 메모리를 가리키는 포인터)란, 어떤 메모리를 가르키는 포인터가 남아있는 상황에서 일부 메모리를 해제해 버림으로써, 다른 개체가 할당받았을지도 모르는 메모리를 참조하게 된 포인터를 말한다.

러스트에서는 어떤 데이터의 참조자를 만들면, 해당 참조자가 스코프를 벗어나기 전에 데이터가 먼저 스코프를 벗어나는지 컴파일러에서 확인해여 댕글림 참조가 생기지 않도록 보장해준다.

## 참조자 규칙

- 단 하나의 가변 참조자만 갖거나, 여러 개의 불변 참조자를 가질 수 있다.
- 참조자는 항상 유효해야 한다.
