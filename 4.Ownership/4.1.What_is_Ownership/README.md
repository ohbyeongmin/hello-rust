# What is ownership?

## 소유권 규칙

- 러스트에서, 각각의 값을 소유자(owner) 가 정해져 있다.
- 한 값의 소유자는 동시에 여럿 존재할 수 없다.
- 소유자가 스코프 밖으로 벗어날 때, 값은 버려진다. (dropped)

## 문자열 리터럴과 String 타입

문자열 리터럴은 컴파일 타임에 내용을 알 수 있으므로, 텍스트가 최종 실행파일에 하드코딩 된다.
컴파일 타임에 크기를 알 수 없고 실행 중 크기가 변할 수도 있는 텍스트는 바이너리 파일에 넣어야 된다.

러스트는 힙에 메모리가 할당되고 해제 되는 방식으로 변수가 자신이 소속된 스코프를 벗어나는 순간 자동으로 메모리를 해제하는 방식으로 해결했다.

```rust
    {
        let s = String::from("hello"); // s는 이 지점부터 유효합니다

        // s를 가지고 무언가 합니다
    }                                  // 이 스코프가 종료되었고, s는 더 이상
                                       // 유효하지 않습니다.
```

`s` 가 스코프 밖으로 벗어나면 `drop` 이라는 특별한 함수를 호출해서 메모리를 해제한다.
이 패턴을 Resource Acquisition Is Initialization (RAII) 라 한다.

## 변수와 데이터 간 상호작용 방식: 이동

```rust
    let s1 = String::from("hello");
    let s2 = s1;
```

String 변수를 선언하게 될 경우 스택에 메모리를 가르키는 포인터, 문자열 길이, 메모리 용량이 저장되고 실제 데이터는 힙 영역에 저장된다.

이때, `s2`에 `s1`를 대입하면 `String` 데이터가 복사된다. 이때 데이터는 스택에 있는 데이터, 즉 포인터, 길이, 용량 값이 복사가 된다. 힙 영역 데이터는 복사되지 않는다.

위 처럼 스택을 복사하여 같은 힙 영역을 가르키고 있을 때 스코프에서 벗어나 메모리를 해제할 경우 어떻게 될까?
각각 메모리를 해제하게 될 경우 중복 해재(double free) 에러가 발생한다. 이는 메모리 안정성 버그 중 하나이며, 보안을 취약하게 만드는 메모리 손상의 원인이다.

메모리 안정성을 보장하기 위해서, 러스트는 `let s2 = s1;` 라인 뒤로는 `s1` 이 더 이상 유효하지 않다고 판단한다.
`s2`가 만들어진 후에 `s1` 을 사용할 경우 작동하지 않는다.

이를 이동(move) 라고 부른다.

러스트는 절대 자동으로 '깊은' 복사로 데이터를 복사하는 일이 없다. 따라서, 러스트가 자동으로 수행하는 모든 복사는 런타임 성능 측면에서 효율적이라 할 수 있다.

### 변수와 데이터 간 상호작용 방식: 클론

`String`의 힙 데이터까지 깊게 복사하고 싶을 땐 `clone` 이라는 공용 메서드를 사용할 수 있다.

```rust
    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {}, s2 = {}", s1, s2);

```

### 스택에만 저장되는 데이터: 복사

```rust
    let x = 5;
    let y = x;

    println!("x = {}, y = {}", x, y);
```

정수형 등 컴파일 타임에 크기가 고정되는 타입은 모두 스택에 저장되기 때문에 `clone`을 호출하지 않아도 `x`는 계속 유효하다.

러스트에는 정수형처럼 스택에 저장되는 타입에 달아 놓을 수 있는 `Copy` 트레이트가 있다. 만약 어떤 타입이 이 `Copy` 트레이트가 구현되어 있다면, 이 타입의 변수는 사용되어도 이동되지 않고 복사되고, 대입 연산 후에도 사용할 수 있다.

하지만 구현하려는 타입이나, 구현하려는 타입 중 일부분에 `Drop` 트레이트가 구현된 경우엔 `Copy` 트레리트를 어노테이션 할 수 없다.

## 소유권과 함수

함수에 변수를 전달할 경우 대입 연산과 마찬가지로 이동이나 복사가 일어난다.

```rust
fn main() {
    let s = String::from("hello");  // s가 스코프 안으로 들어옵니다

    takes_ownership(s);             // s의 값이 함수로 이동됩니다...
                                    // ... 따라서 여기서는 더 이상 유효하지 않습니다

    let x = 5;                      // x가 스코프 안으로 들어옵니다

    makes_copy(x);                  // x가 함수로 이동될 것입니다만,
                                    // i32는 Copy이므로 앞으로 계속 x를
                                    // 사용해도 좋습니다

} // 여기서 x가 스코프 밖으로 벗어나고 s도 그렇게 됩니다. 그러나 s의 값이 이동되었으므로
  // 별다른 일이 발생하지 않습니다.

fn takes_ownership(some_string: String) { // some_string이 스코프 안으로 들어옵니다
    println!("{}", some_string);
} // 여기서 some_string이 스코프 밖으로 벗어나고 `drop`이 호출됩니다.
  // 메모리가 해제됩니다.

fn makes_copy(some_integer: i32) { // some_integer가 스코프 안으로 들어옵니다
    println!("{}", some_integer);
} // 여기서 some_integer가 스코프 밖으로 벗어납니다. 별다른 일이 발생하지 않습니다.
```

## 반환 값과 스코프

소유권은 값을 반환하는 과정에도 이동한다.

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership이 자신의 반환 값을 s1로
                                        // 이동시킵니다

    let s2 = String::from("hello");     // s2가 스코프 안으로 들어옵니다

    let s3 = takes_and_gives_back(s2);  // s2는 takes_and_gives_back로 이동되는데,
                                        // 이 함수 또한 자신의 반환 값을 s3로
                                        // 이동시킵니다
} // 여기서 s3가 스코프 밖으로 벗어나면서 버려집니다. s2는 이동되어서 아무 일도
  // 일어나지 않습니다. s1은 스코프 밖으로 벗어나고 버려집니다.

fn gives_ownership() -> String {             // gives_ownership은 자신의 반환 값을
                                             // 자신의 호출자 함수로 이동시킬
                                             // 것입니다

    let some_string = String::from("yours"); // some_string이 스코프 안으로 들어옵니다

    some_string                              // some_string이 반환되고
                                             // 호출자 함수 쪽으로
                                             // 이동합니다
}

// 이 함수는 String을 취하고 같은 것을 반환합니다
fn takes_and_gives_back(a_string: String) -> String { // a_string이 스코프 안으로
                                                      // 들어옵니다

    a_string  // a_string이 반환되고 호출자 함수 쪽으로 이동합니다
}
```
