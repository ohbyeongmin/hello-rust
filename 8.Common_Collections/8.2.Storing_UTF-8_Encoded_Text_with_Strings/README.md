# Storing UTF-8 Encoded Text with Strings

러스트 문자열이 어려워 보이는 이유.

- 발생할 수 있는 에러를 최대한 표시라는 러스트의 성향
- 많은 프로그래머의 예상보다 문자열이 복잡한 자료구조라는 점
- UTF-8

## 문자열이 뭔가요?

러스트 Core 기능 중 문자열 타입은 오직 하나뿐이며, 일반적으로 참조형인 `&str` 형태로 사용하는 문자열 슬라이스 `str`이다.
이는 UTF-8 으로 인코딩되어 다른 어딘가에 저장된 문자열 데이터의 참조자이다. 예를 들어, 문자열 리터럴은 프로그램의 바이너리 결과물 안에 저장되어 있으며, 그러므로 문자열 슬라이스 이다.

`String` 타입은 러스트 언어의 Core 기능에 구현된 것이 아니고 러스트의 표준 라이브러리를 통해 제공되며, 커질 수 있고, 가변적이며, 소유권을 갖고 있고, UTF-8 으로 인코딩된 문자열 타입이다.

러스타시안들이 '문자열'에 대해 이야기할 때는 보통 `String`과 문자열 슬라이스 `&str` 타입 둘 중 무언가를 이야기 하는 것이다.

## 새로운 문자열 생성하기

`String` 타입은 `Vec<T>`타입에 몇가지 보장, 제한, 기능을 추가한 Wrapper 이다. 따라서 같은 방식으로 동작한다.

```rust
    let mut s = String::new();
```

```rust
    let data = "initial contents";

    let s = data.to_string();

    // 이 메서드는 리터럴에서도 바로 작동합니다:
    let s = "initial contents".to_string();
```

```rust
    let s = String::from("initial contents");
```

## 문자열 업데이트하기

### `push_str`과 `push`를 이용하여 문자열 추가하기

`push_str` 메서드를 사용하여 문자열 슬라이스를 추가하는 것으로 `String`을 키울 수 있다.

```rust
    let mut s = String::from("foo");
    s.push_str("bar");
```

`push` 메서드는 한 개의 글자를 매개변수로 받아서 `String` 에 추가한다.

```rust
    let mut s = String::from("lo");
    s.push('l');
```

### `+` 연산자난 `format!` 매크로

```rust
    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &s2; // s1은 여기로 이동되어 더 이상 사용할 수 없음을 주의하세요
```

`+` 연산자는 `add` 메서드를 사용하는데 이 메서드의 시그니처를 맞추기 위해 위 처럼 사용해야 된다.

```rust
fn add(self, s: &str) -> String {
```

`s2` 에는 `&`가 있는데, 즉 첫 번째 문자열에 두 번째 문자열의 참조자를 더하고 있음을 뜻한다. `String`에는 `&str`만 더할 수 있고, 두 `String` 끼리는 더하지 못한다.

`&s2`를 `add` 호출에 사용할 수 있는 이유는 `&String` 인수가 `&str`로 강제될 수 있기 대문이다. `add` 함수가 호출되면, 러스트는 역참조 강제 변환(defer coercion)을 사용하는데 이것이 `add` 함수 내에서 사용되는 `&s2` 를 `&s2[..]` 로 바꿔준다.

`let s3 = s1 + &s2`는 `s1`의 소유권을 가져다가 `s2`의 내용물의 복사본을 추가한 다음, 결과물의 소유권을 반환한다.

```rust
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = s1 + "-" + &s2 + "-" + &s3;
```

위 코드를 `format!` 매크로로 간단히 만들 수 있다.

```rust
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = format!("{s1}-{s2}-{s3}");
```

## 문자열 내부의 인덱싱

러스트에서 인덱싱 문법을 사용하여 `String` 의 부분에 접근하고자 하면 에러를 얻는다.

### 내부적 표현

```rust
    let hello = String::from("Здравствуйте");
```

위 문자열의 크기는 24 이다. 이는 Здравствуйте 를 UTF-8 으로 인코딩된 바이트들의 크기인데, 각각의 유니코드 스칼라 값이 저장소의 2바이트를 차지하기 때문이다.

따라서, 문자열의 바이트 안의 인덱스는 유효한 유니코드 스칼라 값과 항상 대응되지 않는다.

러스트는 예상치 못한 값을 반환하고 즉시 발견되지 않을 수 있는 버그를 방지하기 위해서 이러한 코드를 전혀 컴파일하지 않고 이러한 오해들을 개발 과정 내에서 일찌감치 방지한다.

### 바이트와 스칼라 값과 문자소 클러스터!

러스트는 세가지 관점: 바이트, 스칼라 값, 문자소 클러스터 로 문자열을 바라본다.

또한, 러스트는 인덱싱 연산이 상수 시간(O(1)) 에 실행될 것으로 기대하는데 반면 `String` 을 가지고는 그러한 성능을 보장하는 것이 불가능하다. 그 이유는 러스트가 문자열 내에 유효한 문자가 몇 개 있는지 알아내기 위해 내용물을 시작 지점부터 인덱스로 지정된 곳까지 훑어야 하기 때문이다.

## 문자열 슬라이싱 하기

```rust
let hello = "Здравствуйте";

let s = &hello[0..4];
```

이는 `s`가 Зд 가 된다.

만약에 `&hello[0..1]` 처럼 문자 바이트의 일부를 슬라이스를 얻으려고 한다면, 러스트는 벡터 내에 유효하지 않은 인덱스에 접근했을 때와 동일한 방식으로 런타임에 패닉을 발생시킬 것입니다.

## 문자열에 대한 반복을 위한 메서드

```rust
for c in "Зд".chars() {
    println!("{c}");
}

З
д
```

```rust
for b in "Зд".bytes() {
    println!("{b}");
}

208
151
208
180
```
